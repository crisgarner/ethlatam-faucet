import DaiContract from "../../../hardhat/deployments/localhost/DAI.json";
import SemaphoreUserRegistryContract from "../../../hardhat/deployments/localhost/SemaphoreUserRegistry.json";
import { ZKEdDSAEventTicketPCDPackage } from "@pcd/zk-eddsa-event-ticket-pcd";
import { NextApiRequest, NextApiResponse } from "next";
import { hexToBigInt } from "viem";
import { createPublicClient, createWalletClient, http, isAddress, parseEther } from "viem";
import { mnemonicToAccount } from "viem/accounts";
import { optimism } from "viem/chains";

const localWalletClient = createWalletClient({
  chain: optimism,
  transport: http(),
});

const client = createPublicClient({
  chain: optimism,
  transport: http(),
});

// const accounts = await localWalletClient.getAddresses();
const account = mnemonicToAccount(process.env.MNEMONIC as string);

const gasDrop = parseEther("0.0015");
const daiDrop = parseEther("1");

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const pcd = await ZKEdDSAEventTicketPCDPackage.deserialize(req.body.pcd);
  const address = req.body.address;
  const semaphoreId = pcd.claim.partialTicket.attendeeSemaphoreId;
  const transactionCount = await client.getTransactionCount({
    address: account.address,
  });
  console.log(transactionCount);

  // ## Validations
  if (!isAddress(address)) {
    return res.status(401).send("Invalid address");
  }

  if (!(await ZKEdDSAEventTicketPCDPackage.verify(pcd))) {
    console.error(`[ERROR] ZK ticket PCD is not valid`);

    return res.status(401).send("ZK ticket PCD is not valid");
  }

  if ("1ebfb986fbac5113f8e2c72286fe9362f8e7d211dbc68227a468d7b919e75003" != pcd.claim.signer[0]) {
    console.error(`[ERROR] PCD is not signed by Zupass`);
    return res.status(401).send("PCD is not signed by Zupass");
  }

  if (!pcd.claim.partialTicket.isConsumed) {
    console.error(`[ERROR Frontend] Ticket not consumed`);
    return res.status(401).send("Ticket not consumed");
  }

  // TODO: Use real nonce generated by the server
  if (pcd.claim.watermark.toString() !== hexToBigInt(address as `0x${string}`).toString()) {
    console.error(`[ERROR] PCD watermark doesn't match`);
    return res.status(401).send("PCD watermark doesn't match");
  }

  // TODO: Check that the event id is the one we expect

  const isVerified = await client.readContract({
    address: "0xCb93dfe111e8441367bb58457AaaF5c2fd4C525B",
    abi: SemaphoreUserRegistryContract.abi,
    functionName: "isVerifiedSemaphoreId",
    args: [semaphoreId],
  });

  if (isVerified) {
    console.error(`[ERROR] User already registred`);
    // return res.status(401).send("User already registred");
    return res.status(200).json({
      error: true,
      pcd: pcd,
      message: `Usuario ya registrado!`,
    });
  }

  // ## Actions
  const registryResult = await localWalletClient.writeContract({
    account: account,
    address: "0xCb93dfe111e8441367bb58457AaaF5c2fd4C525B",
    abi: SemaphoreUserRegistryContract.abi,
    functionName: "addUser",
    args: [address, semaphoreId],
    nonce: transactionCount,
  });

  // Send ETH to the user. This is just for testing purposes, and it could be any backend action.
  await localWalletClient.sendTransaction({
    to: req.body.address,
    value: gasDrop,
    account: account,
    nonce: transactionCount + 1,
  });

  await localWalletClient.writeContract({
    account: account,
    address: "0xda10009cbd5d07dd0cecc66161fc93d7c9000da1",
    abi: DaiContract.abi,
    functionName: "transfer",
    args: [address, daiDrop],
    nonce: transactionCount + 2,
  });

  return res.status(200).json({
    message: `ðŸŽ‰ PCD verified! You can vote now! Also 0.0015 ETH and 10 DAIs have been sent to ${address}!`,
    txHash: registryResult,
  });
}
